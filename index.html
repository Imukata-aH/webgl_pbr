<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>PBR Sample Scene</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <div id="container" style="width: 100%; height: 100%;"></div>
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">
			precision mediump float;
			precision mediump int;

			varying vec4 vPosition;
			varying vec3 vViewPosition;
			varying vec4 vNormal;
			varying vec3 vViewNormal;

			void main(){
				vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
				vNormal = vec4(normal.xyz, 0.0);
				vViewNormal = normalMatrix * normal.xyz;
				vPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

				gl_Position = vPosition;
			}
        </script>

        <script id="fragmentShader_param" type="x-shader/x-fragment">
			precision mediump float;
			precision mediump int;

			uniform vec3 u_lightColor;
			uniform vec3 u_lightPos;
			uniform vec3 u_ambientColor;

			uniform vec3 u_baseColor;
			uniform float u_roughness;
			uniform float u_metalness;
			
			uniform samplerCube u_tCube;

			varying vec4 vPosition;
			varying vec3 vViewPosition;
			varying vec4 vNormal;
			varying vec3 vViewNormal;

			#define M_PI 3.1415926535897932384626433832795

			float dotClamped(vec3 a, vec3 b)
			{
				return max(dot(a, b), 0.0);
			}

			// Fresnel refrection term
			// Schlick's approximation
			vec3 F(vec3 specular, float product)
			{
				return specular + ( 1.0 - specular ) * pow(1.0 - product, 5.0);
			}
        </script>

		<script id="NDF_BlinnPhong" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				float powTerm = ( 2.0 / a2 ) - 2.0;
				return ( pow( NdH, powTerm ) / ( M_PI * a2 ) );
			}
		</script>

		<script id="NDF_Beckman" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				float NdH2 = NdH * NdH;
				float denom = M_PI * a2 * NdH2 * NdH2;
				float num = exp( ( NdH2 - 1.0 ) / ( a2 * NdH2 ) );
				return num / denom;
			}
		</script>

		<script id="NDF_GGX" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				return a2 / (M_PI * pow(pow(NdH, 2.0) * (a2 - 1.0) + 1.0, 2.0));
			}
		</script>

		<script id="G_Implicit" type="x-shader/x-fragment">
			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				return NdL * NdV;
			}
		</script>

		<script id="G_Neumann" type="x-shader/x-fragment">
			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				float num = NdL * NdV;
				float denom = max(NdL, NdH);
				return num / denom;
			}
		</script>

		<script id="G_CookTorrance" type="x-shader/x-fragment">
			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				float minDot = min( NdV, NdL );
				float comparison = ( 2.0 * NdH * minDot ) / VdH;
				return min( 1.0, comparison );
			}
		</script>

		<script id="G_Kelemen" type="x-shader/x-fragment">
			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				return ( NdL * NdV ) / ( VdH * VdH );
			}
		</script>

		<script id="G_Beckmann" type="x-shader/x-fragment">
			float G_BeckmannHelper_c(float a, float dotTerm)
			{
				float sqrtTerm = sqrt( 1.0 - ( dotTerm * dotTerm ));
				return dotTerm / ( a * sqrtTerm );
			}

			float G_BeckmannHelper_G1(float c)
			{
				if( c < 1.6 )
				{
					float c2 = c * c;
					float num = 3.535 * c + 2.181 * c2;
					float denom = 1.0 + 2.276 * c + 2.577 * c2;
					return num / denom;
				}
				else
				{
					return 1.0;
				}
			}

			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				float cV = G_BeckmannHelper_c( a, NdV );
				float cL = G_BeckmannHelper_c( a, NdL );

				float GV = G_BeckmannHelper_G1( cV );
				float GL = G_BeckmannHelper_G1( cL );

				return GV * GL;
			}
		</script>

		<script id="G_ShlickBeckmann" type="x-shader/x-fragment">
			float HelperG1(float k, float dotTerm)
			{
				return dotTerm / ((dotTerm * (1.0 - k)) + k);
			}

			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				float k = a * sqrt( 2.0 / M_PI );
				float GV = HelperG1( k, NdV );
				float GL = HelperG1( k, NdL );
				return GV * GL;
			}
		</script>

		<script id="G_ShlickGGX" type="x-shader/x-fragment">
			float HelperG1(float k, float dotTerm)
			{
				return dotTerm / ((dotTerm * (1.0 - k)) + k);
			}

			float G(float a, float NdH, float VdH, float NdV, float NdL)
			{
				float k = a * 0.5;
				float GV = HelperG1( k, NdV );
				float GL = HelperG1( k, NdL );
				return GV * GL;
			}
		</script>

		<script id="fragmentShader_main" type="x-shader/x-fragment">
			// Generate van der Corput sequence as Low Discrepancy Sequence
			// [in] i    : 変換する値
			// [in] base : 基数
			float RadicalInverse_VdC(int i, int base)
			{
				float reversedBase = 1.0 / float(base);				
				float f = 1.0 * reversedBase;
				float factor = f;
				float h = 0.0;
				for( int n = 0; n < 100000; n++ )	// dummy condition due to GLSL ES loop constraint
				{
					h += float(mod(float(i), float(base))) * factor;
					factor *= f;
					i = int( float(i) * reversedBase);
					if( i <= 0) { break; }
				}

				return h;
			}

			// Generate Hammersley point set
			vec2 Hammersly(int i, int numSamples)
			{
				vec2 Xi = vec2(0.0);
				
				float i_float = float(i);
				float N_float = float(numSamples);
				Xi.x = i_float / N_float;
				// Y conponent of Hammersly point set is van der Corput sequence.
				Xi.y = RadicalInverse_VdC(i, 2);

				return Xi;
			}

			vec3 ImportanceSamplingGGX(vec2 Xi, float a, vec3 NN)
			{
				float phi = 2.0 * M_PI * Xi.x;
				float cosTheta = sqrt( (1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y) );
				float sinTheta = sqrt( 1.0 - cosTheta * cosTheta );

				vec3 H;
				H.x = sinTheta * cos(phi);
				H.y = sinTheta * sin(phi);
				H.z = cosTheta;

				vec3 upVector = abs(NN.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangentX = normalize(cross(upVector, NN));
				vec3 tangentY = cross(NN, tangentX);

				// Tangent to world space
				return tangentX * H.x + tangentY * H.y + NN * H.z;
			}

			// Solve radiance integral using quasi-Monte Carlo (importance sampling)
			vec3 SpecularIBL(vec3 baseSpecular, float a, vec3 NN, vec3 V)
			{
				
				vec3 specularLighting = vec3(0.0);
				const int numSamples = 32;
				
				for (int sample = 0; sample < numSamples; sample++) 
				{
					// Monte Carlo 法のサンプル列として Hammersly Point Set を利用
					vec2 Xi = Hammersly(sample, numSamples);

					vec3 H = ImportanceSamplingGGX(Xi, a, NN);
					vec3 L = 2.0 * dot(V, H) * H - V;

					float NdV = dotClamped(NN, V);
					float NdL = dotClamped(NN, L);
					float NdH = dotClamped(NN, H);
					float VdH = dotClamped( V, H);
					float LdH = dotClamped( L, H);

					if(NdL > 0.0)
					{
						vec3 sampleColor = textureCube(u_tCube, L).xyz;

						float getometry = G(a, NdH, VdH, NdV, NdL);
						vec3  fresnel   = F(baseSpecular, LdH);

						// Given formula deformation of importance sampling, reflectance equation is deformed as below.
						// Incident light (Li * cos) = sampleColor * NdL
						// Micofacet specular (f)    = (F * G * D) / (4 * NdL * NdV)
						// pdf                       = (D * NdH) / (4 * VdH)
						specularLighting += (sampleColor * fresnel * getometry * VdH) / (NdH * NdV);
					}
				}

				return specularLighting / float(numSamples);
			}

			void main() 
			{
				// 必要なベクトルの計算
				// ベクトル計算はビュースペースで統一

				vec3 viewPosition = normalize(vViewPosition);
				
				vec4 viewLightPos = viewMatrix * vec4(u_lightPos, 1.0);
				vec3 L = viewLightPos.xyz - viewPosition.xyz;
				L = normalize(L);
				vec3 NN = normalize(vViewNormal.xyz);	// normalized normal
				vec3 V = normalize(-vViewPosition);
				vec3 H = normalize(L + V);

				float NdV = dotClamped(NN, V);
				float NdL = dotClamped(NN, L);
				float NdH = dotClamped(NN, H);
				float LdH = dotClamped( H, L);
				float VdH = dotClamped( H, V);


				// 設置した光源に対するシェーディング(punctual light source の単一光源を前提)
				vec3 specularColor = vec3(0.0);
				vec3 diffuseColor  = vec3(0.0);

				// Calculate base specular color (= F(0)) and base diffuse color based on metalness.
				// Non-metal material's specular color = vec3(0.04) gray.
				// Metalic material's specular color becomes to be base color.
				// Mix between metal and non-metal material.
				vec3 baseSpecular = (( 1.0 - u_metalness ) * vec3( 0.04 )) + ( u_metalness * u_baseColor );
				vec3 baseDiffuse  = (( 1.0 - u_metalness ) * u_baseColor ) + ( u_metalness *  vec3( 0.0 ));
				
				// // Cook-Torrance Microfacet BRDF による Specular 計算
				float a = u_roughness * u_roughness;

				vec3 fresnelSpecular = F(baseSpecular, LdH);
				float geometryFactor = G(a, NdH, VdH, NdV, NdL);
				float normalDistributionFactor = N(a, NdH);

				vec3 microfacetSpecularTerm = (fresnelSpecular * geometryFactor * normalDistributionFactor) / (4.0 * NdL * NdV + 0.00001);

				specularColor += microfacetSpecularTerm * u_lightColor * NdL;

				// BRDF の Diffuse 項を計算
				vec3 diffuseTerm = baseDiffuse / M_PI;			// Lambertian diffuse
				diffuseColor += diffuseTerm * u_lightColor * NdL;	
				diffuseColor *= (vec3(1.0) - fresnelSpecular);	// energy conservation
				
				// Assumed punctual light sources, M_PI need to be multiplied.
				diffuseColor  *= M_PI;
				specularColor *= M_PI;

				// Image Based Lighting による specular color を加算
				vec3 specularColorFromIBL = SpecularIBL(baseSpecular, a, NN, V);
				specularColor += specularColorFromIBL;

				gl_FragColor = vec4(diffuseColor + specularColor + u_ambientColor * u_baseColor, 1.0);
			}
		</script>

        <script src="./main.js"></script>
	</body>
</html>