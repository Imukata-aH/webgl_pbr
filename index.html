<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>PBR Sample Scene</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <div id="container" style="width: 100%; height: 100%;"></div>
		<script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">
			precision mediump float;
			precision mediump int;

			varying vec4 vPosition;
			varying vec3 vViewPosition;
			varying vec4 vNormal;
			varying vec3 vViewNormal;

			void main(){
				vViewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
				vNormal = vec4(normal.xyz, 0.0);
				vViewNormal = normalMatrix * normal.xyz;
				vPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

				gl_Position = vPosition;
			}
        </script>

        <script id="fragmentShader_param" type="x-shader/x-fragment">
			precision mediump float;
			precision mediump int;

			uniform vec3 u_lightColor;
			uniform vec3 u_lightDir;
			uniform vec3 u_lightPos;
			uniform vec3 u_viewPos;
			uniform vec3 u_diffuseColor;
			uniform float u_roughness;
			uniform vec3 u_fresnel;
			uniform float u_alpha;
			uniform vec3 u_ambientColor;
			uniform samplerCube u_tCube;
			uniform float u_time;


			varying vec4 vPosition;
			varying vec3 vViewPosition;
			varying vec4 vNormal;
			varying vec3 vViewNormal;
			varying vec2 vUv;

			#define M_PI 3.1415926535897932384626433832795

			float dotClamped(vec3 a, vec3 b)
			{
				return max(dot(a, b), 0.0);
			}

			// Fresnel refrection term
			// Schlick's approximation
			// F0 は波長（RGB）ごとの値である
			vec3 F(vec3 f0, vec3 v, vec3 h)
			{
				float VdH = dot(v, h);
				float fresnelX = f0.x + pow((1.0 - f0.x) * VdH, 5.0);
				float fresnelY = f0.y + pow((1.0 - f0.y) * VdH, 5.0);
				float fresnelZ = f0.z + pow((1.0 - f0.z) * VdH, 5.0);
				return vec3(fresnelX, fresnelY, fresnelZ);
				//return f0 + ((1.0 - f0) * pow((1.0 - f0) * VdH, 5.0));
			}
        </script>

		<script id="NDF_BlinnPhong" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				float powTerm = ( 2.0 / a2 ) - 2.0;
				return ( pow( NdH, powTerm ) / ( M_PI * a2 ) );
			}
		</script>

		<script id="NDF_Beckman" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				float NdH2 = NdH * NdH;
				float denom = M_PI * a2 * NdH2 * NdH2;
				float num = exp( ( NdH2 - 1.0 ) / ( a2 * NdH2 ) );
				return num / denom;
			}
		</script>

		<script id="NDF_GGX" type="x-shader/x-fragment">
			float N(float a, float NdH)
			{
				float a2 = a*a;
				return a2 / (M_PI * pow(pow(NdH, 2.0) * (a2 - 1.0) + 1.0, 2.0));
			}
		</script>

		<script id="G_Implicit" type="x-shader/x-fragment">
			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				return NdL * NdV;
			}
		</script>

		<script id="G_Neumann" type="x-shader/x-fragment">
			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float num = NdL * NdV;
				float denom = max(NdL, NdH);
				return num / denom;
			}
		</script>

		<script id="G_CookTorrance" type="x-shader/x-fragment">
			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float NdH = dotClamped( NN, H );
				float VdH = dotClamped( V, H );
				float minDot = min( NdV, NdL );
				float comparison = ( 2.0 * NdH * minDot ) / VdH;
				return min( 1.0, comparison );
			}
		</script>

		<script id="G_Kelemen" type="x-shader/x-fragment">
			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float VdH = dotClamped(V, H);
				return ( NdL * NdV ) / ( VdH * VdH );
			}
		</script>

		<script id="G_Beckmann" type="x-shader/x-fragment">
			float G_BeckmannHelper_c(float a, float dotTerm)
			{
				float sqrtTerm = sqrt( 1.0 - ( dotTerm * dotTerm ));
				return dotTerm / ( a * sqrtTerm );
			}

			float G_BeckmannHelper_G1(float c)
			{
				if( c < 1.6 )
				{
					float c2 = c * c;
					float num = 3.535 * c + 2.181 * c2;
					float denom = 1.0 + 2.276 * c + 2.577 * c2;
					return num / denom;
				}
				else
				{
					return 1.0;
				}
			}

			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float cV = G_BeckmannHelper_c( a, NdV );
				float cL = G_BeckmannHelper_c( a, NdL );

				float GV = G_BeckmannHelper_G1( cV );
				float GL = G_BeckmannHelper_G1( cL );

				return GV * GL;
			}
		</script>

		<script id="G_ShlickBeckmann" type="x-shader/x-fragment">
			float HelperG1(float k, float dotTerm)
			{
				return dotTerm / ((dotTerm * (1.0 - k)) + k);
			}

			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float k = a * sqrt( 2.0 / M_PI );
				float GV = HelperG1( k, NdV );
				float GL = HelperG1( k, NdL );
				return GV * GL;
			}
		</script>

		<script id="G_ShlickGGX" type="x-shader/x-fragment">
			float HelperG1(float k, float dotTerm)
			{
				return dotTerm / ((dotTerm * (1.0 - k)) + k);
			}

			float G(float a, vec3 NN, vec3 H, vec3 L, vec3 V, float NdV, float NdL)
			{
				float k = a * 0.5;
				float GV = HelperG1( k, NdV );
				float GL = HelperG1( k, NdL );
				return GV * GL;
			}
		</script>

		<script id="fragmentShader_main" type="x-shader/x-fragment">
			void main() 
			{
				// 必要なベクトルの計算
				// ベクトル計算はビュースペースで統一

				vec3 viewPosition = normalize(vViewPosition);
				
				vec4 viewLightPos = viewMatrix * vec4(u_lightPos, 1.0);
				vec3 L = viewLightPos.xyz - viewPosition.xyz;
				L = normalize(L);
				vec3 NN = normalize(vViewNormal.xyz);	// normalized normal
				vec3 V = normalize(-vViewPosition);
				vec3 H = normalize(L + V);

				float NdV = max(dot(NN, V), 0.0);
				float NdL = max(dot(NN, L), 0.0);
				float NdH = max(dot(NN, H), 0.0);

				// 設置した光源に対するシェーディング(単一光源を前提)
				// Cook-Torrance モデルを使用
				
				// Microfacet モデルによる BRDF を計算

				// Microfacet BRDF の Specular 項
				float a = u_roughness * u_roughness;

				vec3 fresnelSpecular = F(u_fresnel, L, H);
				float geometryFactor = G(a, NN, H, L, V, NdV, NdL);
				float normalDistributionFactor = N(a, NdH);

				vec3 microfacetSpecularTerm = (fresnelSpecular * geometryFactor * normalDistributionFactor) / (4.0 * NdL * NdV + 0.00001);

				vec3 specularColor = microfacetSpecularTerm * u_lightColor * NdL;

				// Microfacet BRDF の Diffuse 項
				vec3 microfacetDiffuseTerm = u_diffuseColor / M_PI;	// Lambertian diffuse
				vec3 diffuseColor = microfacetDiffuseTerm * u_lightColor * NdL;
				diffuseColor *= (vec3(1.0) - fresnelSpecular);	// energy conservation

				gl_FragColor = vec4(diffuseColor + specularColor + u_ambientColor * u_diffuseColor, 1.0);
			}
		</script>

        <script src="./main.js"></script>
	</body>
</html>